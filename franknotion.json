[{"pageContent":"This is a complete quick reference or ‚Äúcheat sheet‚Äù for Notion formulas. On this page you‚Äôll find one or more example formulas for every constant, operator, and function available in the Notion formula editor. This cheat sheet is meant to be a quick, easy-to-use bookmark. It is a companion to my complete Notion Formula Reference. There, you‚Äôll find comprehensive technical documentation on Notion formulas, including: Full explanations for every constant, operator, and function Detailed tutorials for creating formula properties and working in the formula editor A full breakdown of Notion formula syntax Advanced guides on Notion regular expressions, formula errors, data type conversion, and more You may also want to check out my Formula Examples Database in Notion itself; there, you‚Äôll find more than 80 example databases demonstrating how to use every formula component listed here. Notion Formula Terms Here are some of the most common terms you‚Äôll run across when working with Notion formulas. Each link here will take you to a full page in the Formula Reference where you can learn more. Property ‚Äì other properties that exist in your Notion database. Constant ‚Äì mathematical constants e and œÄ, plus the Boolean values true and false. Operator ‚Äì symbols that perform operations on 1-3 operands. Includes mathematical operators (such as add), Boolean operators (such as not), and the ternary operator (if). Function ‚Äì pre-defined formulas that you can use to accomplish complex things quickly. Examples include concat (combines strings) and dateAdd (adds x units of time to a date). Arguments are the accepted pieces of data used within functions: // function_name(argument_1, argument_2) divide(10,2) // Output: 5 // Note that spaces between arguments are optional, but // commas are required. concat(\"My\", \" \", \"Chemical\", \" \",\"Romance\") // Output: My Chemical Romance Notion formulas support four distinct data types: String ‚Äì text content Number ‚Äì numeric characters, on which mathematical operations can be performed Boolean/Checkbox ‚Äì true/false values Date ‚Äì date objects Good to know: A Notion formula can only return data of a single type. When working with multiple data types, make sure to use type conversion to convert everything to a single type in order to avoid errors. Constants e The mathematical constant e is known as Euler‚Äôs Number, and approximately equals 2.718281828459045. Full reference: e e // Output: 2.718281828459 500 * e ^ (.3 * 10) // Output: 10042.768461593832 pi The mathematical constant pi (œÄ) equals (roughly) 3.1415926559. Full reference: pi pi // Output: 3.14159265359 pi * 10^2 // Output: 314.159265358979 true The true constant represents the Boolean output true. Its opposite is false. Full reference: true true // Output: true (checked checkbox) true ? \"üòÄ\" : \"üò≠\" // Output: üòÄ false The false constant represents the Boolean output false. Its opposite is true. Full reference: false false // Output: false (unchecked checkbox) false ? \"üòÄ\" : \"üò≠\" // Output: üò≠ Operators if The if() operator allows you to write if-then statements within a Notion formula. Full reference: if // if() syntax if(prop(\"Type\")==\"Mammal\",true,false) // Output: true // ternary syntax prop(\"Type\")==\"Mammal\" ? true : false // Output: true // Nested if statement if( prop(\"Age\") < 13, \"Child\", if( prop(\"Age\") < 19, \"Teenager\", \"Adult\" ) ) add The add (+) operator allows you to: Perform addition on numbers Concatenate strings ‚Äì i.e. combine them (also doable with concat()) Full reference: add Usage: + or add() 2 + 5 // Output: 7 \"Monkey D.\" + \" Luffy\" // Output: Monkey D. Luffy add(4,7) // Output: 11 add(\"Monkey D.\",\" Luffy\") // Output: Monkey D. Luffy subtract The subtract (-) operator allows you to subtract two numbers and return their difference. Full reference: subtract Usage: - or subtract() 12 - 5 // Output: 7 subtract(5,12) // Output: -7 multiply The multiply (*) operator allows you to multiply two numbers together and get their product. Full reference: multiply Usage: * or multiply() 12 * 4 // Output: 48 multiply(12,-4) // Output: -48 divide The divide (/) operator allows you to divide two numbers and get their quotient. Full reference: divide Usage: / or divide() 12 / 4 // Output: 3 divide(12,-4) // Output: -3 pow The power (^) operator (also known as the exponentiation operator) allows you to raise a number to a higher power. Full reference: pow Usage: ^ or pow() 3 ^ 4 // Output: 81 pow(4,3) // Output: 64 2 ^ 2 ^ 3 // Output: 256 - evaluates as 2 ^ (2 ^ 3) mod The remainder (%) operator allows you to get the remainder after dividing the first operand with the second operand. Full reference: mod Usage: % or mod() 19 % 12 // Output: 7 19 mod 12 // Output: 7 mod(-19,12) // Output: -7 unaryMinus The unaryMinus (-) operator negates a number. Full reference: unaryMinus Usage: - or unaryMinus() -42 // Output: -42 -(-42) // Output: 42 unaryMinus(42) // Output: -42 unaryPlus The unaryPlus (+) operator is used to convert Booleans and numeric strings to numbers. Full reference: unaryPlus Usage: + or unaryPlus() +\"42\" // Output: 42 +true // Output: 1 +false // Output: 0 unaryPlus(\"42\") // Output: 42 20 + + \"30\" // Output: 50 -+\"30\" // Output: -30 20 + - + \"30\" // Output? -10 [Notion will rewrite this to 20 + -(+\"30\")] not The not operator inverts the truth value of a Boolean/Checkbox value in a Notion formula. Another way of thinking about it is that it returns true only if its operand is false. It accepts Boolean operands. Full reference: not not true // Output: false not(true) // Output: false not empty(\"Hello\") // Output: true not if(50>40,true,false) // Output: false and The and operator returns true if and only if both of its operands have a true Boolean value. Otherwise, it will return false. It accepts Boolean operands. Full reference: and true and true // Output: true true and false // Output: false and(1>0,0<4) // Output: true if(true and true, \"Happy\", \"Sad\") // Output: \"Happy\" if(true and false, \"Happy\", \"Sad\") // Output: \"Sad\" if(5>4 and 1<3, true, false) // Output: true if(length(\"Monkey D. Luffy\") > 5 and length(\"Monkey D. Luffy\") < 100, true, false) // Output: true 4>2 and 3<4 and 7==7 ? true : false // Output: true or The or operator returns true if either one of its operands is true. It accepts Boolean operands. Full reference: or true or false // Output: true false or true // Output: true false or false // Output: false 10 > 20 or \"Cat\" == \"Cat\" // Output: true 10 > 20 or \"Cat\" == \"Dog\" or true // Output: true equal The equality (==) operator returns true if its operands are equal. It accepts operands of all data types ‚Äì strings, numbers, Booleans, and dates. Full reference: equal 1 == 1 // Output: True equal(1,1) // Output: True 1 == 2 // Output: False \"1\" == 1 // Type mismatch error +\"1\" == 1 // Output: True (uses the unaryPlus operator to convert \"1\" to a number 2^2 == 4 // Output: True length(\"Monkey D. Luffy\") == 15 // Output: True unequal The inequality (!=) operator returns true if its operands are not equal. It accepts operands of all data types ‚Äì strings, numbers, Booleans, and dates. Full reference: unequal 1 != 2 // Output: True 1 != 1 // Output: False unequal(\"Cat\",\"Dog\") // Output: True \"1\" != 2 // Type mismatch error 2^3 != 10 // Output: True larger The larger (>) operator returns true if its left operand is greater than its right operand. It accepts numeric, date, and Boolean operands. Full reference: larger 2 > 1 // Output: true 42 > 50 // Output: false // Boolean values equate to 1 (true) and 0 (false). true > false // Output: true true > true // Output: false // For dates, \"less than\" equates to \"before\". now() > dateSubtract(now(), 1, \"days\") // Output: true largerEq The larger or equal (>=) operator returns true if its left operand is greater than or equal to its right operand. It accepts numeric, date, and Boolean operands. Full reference: largerEq 2 >= 1 // Output: true 42 >= 42 // Output: true // Boolean values equate to 1 (true) and 0 (false). true >= false // Output: true true >= true // Output: true // For dates, \"less than\" equates to \"before\". now() >= now() // Output: true smaller The smaller (<) operator returns true if its left operand is less than its right operand. It accepts numeric, date, and Boolean operands. Full reference: smaller 2 < 1 // Output: false 42 < 50 // Output: true // Boolean values equate to 1 (true) and 0 (false). false < true // Output: true true < true // Output: false // For dates, \"less than\" equates to \"before\". now() < dateAdd(now(), 1, \"months\") // Output: true smallerEq The smaller or equal (<=) operator returns true if its left operand is less than or equal to its right operand. It accepts numeric, date, and Boolean operands. Full reference: smallerEq 2 <= 3 // Output: true 42 <= 42 // Output: true // Boolean values equate to 1 (true) and 0 (false). false <= true // Output: true true <= true // Output: true // For dates, \"less than\" equates to \"before\". now() <= now() // Output: true Functions concat The concat() function concatenates (aka combines) its arguments. It accepts one or more string arguments, and outputs a single combined string. Full reference: concat concat(\"Roronoa \",\"Zoro\") // Output: Roronoa Zoro \"Roronoa \" + \"Zoro\" // Output: Roronoa Zoro concat(\"Chopper\") // Output: Chopper (this is pointless, but it works) concat(\"Monkey\", \" D.\", \"Luffy\", \" will \", \"be\", \" King of the Pirates\") // Output: Monkey D. Luffy will be King of the Pirates // use \"\\n\" to create line breaks concat(\"Luffy \\n\", \"Zoro \\n\", \"Sanji \\n\", \"Nami \\n\") // Output: // Luffy // Zoro // Sanji // Nami join The join() function takes its first argument and inserts it in between each of its additional arguments. It accepts only string arguments. Full reference: join join(\", \",\"Luffy\",\"Zoro\",\"Nami\",\"Chopper\") // Output: Luffy, Zoro, Nami, Chopper // Use \"\\n\" to add line breaks join(\"\\n\",\"Luffy\",\"Zoro\",\"Nami\",\"Chopper\") // Output: // Luffy // Zoro // Nami // Chopper slice The slice() function allows you to ‚Äúslice‚Äù up a string and output a smaller piece of it. Full reference: slice slice(\"Dangerfield\",0,6) // Output: Danger slice(\"Monkey D. Luffy\",0,6) // Output: Monkey slice(\"Monkey D. Luffy\", 10, 15) // Ouput: Luffy slice(\"‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè\",0,6) + slice(\"‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã\",0,6) // Output: ‚óè‚óè‚óè‚óè‚óè‚óã‚óã‚óã‚óã‚óã length The length() function outputs a number that corresponds to the length of a string. Full reference: length length(\"Monkey D. Luffy\") // Output: 15 length(\"Supercalifragilisticexpialidocious\") // Output: 34 length(\"Doctor Doom\") // Output: 11 format The format() function formats its argument as a string. It accepts all data types, including dates, Booleans, numbers, and even strings. Full reference: format format(4) // Output: 4 (as a string) format(5+5) // Output: 10 (as a string) format(true) // Output: true (as a string) format(5>4) // Output: true (as a string) format(now()) // Output: June 20, 2022 2:23 PM (changes with now()'s value) \"There are \" + format(10) + \" Straw Hat members.\" // Output: There are 10 Straw Hat members. toNumber The toNumber() function converts its argument to a number if it can do so. It is useful for converting strings, Booleans, and dates to numbers. Full reference: toNumber toNumber(\"42\") // Output: 42 (number) toNumber(true) // Output: 1 toNumber(false) // Output: 0 toNumber(5>3) // Output: 1 toNumber(now()) // Output: 1655757000000 (changes with now()'s value) contains The contains() function tests whether the first argument contains the second argument. It only accepts strings (or nested functions that output strings). Full reference: contains contains(\"Monkey D. Luffy\", \"Luffy\") // Output: true contains(\"Monkey D. Luffy\", \"keyLuf\") // Output: false // Invalid contains(true, \"true\") // Error: Type mismatch true is not a Text. replace The replace() function searches a string for a pattern (which can be a regular expression), and replaces the first match it finds with another string. For replace(), replaceAll(), and test(), you may also want to refer to my full guide on using regular expressions in Notion. Full reference: replace replace(\"Pogo\",\"Po\",\"Dog\") // Output: Doggo // Matches the first occurrance, unless otherwise specified replace(\"Dogs Dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats Dogs Dogs // $ tells the regex engine \"start from end of line and work backwards\" replace(\"Dogs Dogs Dogs\",\"Dogs$\",\"Cats\") // Output: Dogs Dogs Cats // Matches are case-sensitive replace(\"thomas\",\"t\",\"T\") // Output: Thomas // You can use brackets [] to create a set of characters, // any of which will be matched replaceAll(\"thomas\", \"[Tt]homas\", \"Megatron\") // Output: Megatron // You can also create a group with () and then use the | (OR) operator replaceAll(\"thomas\", \"(T|t)homas\", \"Megatron\") // Megatron // Accepts regex metacharacters, such as \"\\\\b\" which denotes \"word boundary\". // Without \\\\b, this would output \"Thwas is Sparta\" replace(\"This is Sparta\",\"\\\\bis\\\\b\",\"was\") // Output: This was Sparta replaceAll The replaceAll() function searches a string for a pattern (which can be a regular expression), and replaces ALL matches it finds with another string. Full reference: replaceAll replaceAll(\"Dogs Dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats Cats Cats // Matches are case-sensitive replaceAll(\"Dogs dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats dogs Cats // You can use brackets [] to create a set of characters, // any of which will be matched replaceAll(\"Dogs dogs Dogs\", \"[Dd]ogs\", \"Cats\") // Output: Cats Cats Cats // You can also create a group with () and then use the | (OR) operator replaceAll(\"Dogs dogs Dogs\", \"(D|d)ogs\", \"Cats\") // Cats Cats Cats // Accepts regex metacharacters, such as \"\\\\b\" which denotes \"word boundary\". // Without \\\\b, this would output \"Thwas was Sparta\" replaceAll(\"This is Sparta\",\"\\\\bis\\\\b\",\"was\") // Output: This was Sparta // replaceAll() is a great way to count elements in a string. // Do this by using a regular expression to remove all characters // except the commas that separate the elements (see the example // database below for an in-depth look at this) replaceAll(\"Dog, Cat, Monkey, Bat, Gorilla\",\"[^,]\",\"\") // Output: ,,,, // Apply length() + 1 to get the count! test The test() function allows you to test whether a string contains a substring, the latter of which can be a regular expression. If it does, the function returns true. Full reference: test test(\"Monkey D. Luffy\", \"Luffy\") // Output: true // test() is case-sensitive test(\"Monkey D. Luffy\", \"luffy\") // Output: false // You can use brackets [] to create a set of characters, // any of which will be matched test(\"Monkey D. luffy\", \"[Ll]uffy\") // Output: true // You can also create a group with () and then use the | (OR) operator test(\"Monkey D. luffy\", \"(L|l)uffy\") // Output: true empty The empty() function returns true if its argument is empty, or has a value that equates to empty ‚Äì including 0 and false. Full reference: empty empty(\"\") // Output: true empty(0) // Output: true empty(false) // Output: true // Assume a row where the Name property is currently blank empty(prop(\"Name\")) // Output: true // Assume a row where the Name property contains text not empty(prop(\"Name\")) // Output: true // The same result can be accomplished with conditional operators // (Assume the Name property contains text in this row) empty(prop(\"Name\")) ? false : true // Output: true abs The abs() function calculates the absolute value of a number. Full reference: abs abs(-42) // Output: 42 abs(42) // Output: 42 cbrt The cbrt() function returns the cube root of its argument. cbrt() accepts only numbers. Full reference: cbrt cbrt(8) // Output: 2 cbrt(64) // Output: 4 // Total surface area of cube with Volume 300m¬≥ // using formula 6a¬≤, where a = edge length 6 * cbrt(300)^2 // Output: 268.88428479343 ceil The ceil() function returns the smallest integer that is greater than or equal to its argument. Full reference: ceil ceil(4.2) // Output: 5 ceil(3.845) // Output: 4 ceil(4) // Output: 4 // Calculate the donated change in a round-up donation // Assume prop(\"Subtotal\") is $5.34 ceil(prop(\"Subtotal\")) - prop(\"Subtotal\") // Output: $0.66 exp The exp() function allows you to raise Euler‚Äôs Number e (the base of the natural logarithm) to a higher power and get the output, where the argument is the exponent of e. Full reference: exp exp(2) // Output: 7.389056098931 exp(5) // Output: 148.413159102577 e^5 // Output: 148.413159102577 exp(ln(5)) // Output: 5 ln(exp(5)) // Output 5 floor The floor() function returns the largest integer that is less than or equal to its argument. Full reference: floor floor(4.2) // Output: 4 floor(3.845) // Output: 3 floor(4) // Output: 4 ln The ln() function returns the natural logarithm of a number. Full reference: ln ln(20) // Output: 2.995732273554 ln(e) // Output: 1 log10 The log10() function returns the base-10 logarithm of a number. Full reference: log10 log10(1000) // Output: 3 log10(10) // Output: 1 log2 The log2() function returns the base-2 logarithm of a number. Full reference: log2 log2(64) // Output: 6 log2(2) // Output: 1 max The max() function returns the greatest of one or more numbers. max() accepts only numbers or properties that output numbers (it will not auto-convert Booleans). Full reference: max max(3,5,4) // Output: 5 // Assume prop(\"Num\") contains 20 max(prop(\"Num\"),13,5) // Output: 20 // Other data types must be converted to number max(1,+true,+\"3\",9) // Output: 9 // Here, the + operator (unaryPlus) is used to convert // true and \"3\" to numbers. min The min() function returns the smallest of one or more numbers. min() accepts only numbers or properties that output numbers (it will not auto-convert Booleans). Full reference: min min(4,1,9,-3) // Output: -3 // Assume prop(\"Num\") contains 3 max(prop(\"Num\"),13,5) // Output: 3 // Other data types must be converted to number min(3,8,+false) // Output: 0 // Here, the + operator (unaryPlus) is used to convert // false to a number (0) round The round() function rounds its argument to the nearest integer (whole number). Full reference: round round(4.5) // Output: 5 round(4.49) // Output: 4 round(-4.49) // Output: -4 round(-4.5) // Output: -4 round(-4.51) // Output: -5 // Round to two decimal places round(4.158015*100)/100 // Output: 4.16 // Round to three decimal places round(5145.018394*10000)/10000 // Output: 5145.0184 sign The sign() function returns the sign of its argument. It indicates whether its argument is positive, negative, or zero. Full reference: sign sign(-5) // -1 sign(5) // 1 sign(0) // 0 sign(+\"-1\") // -1 sqrt The sqrt() function returns the square root of its argument. sqrt() accepts only numbers. Full reference: sqrt sqrt(16) // Output: 4 sqrt(100) // Output: 10 sqrt(73-3^2) // Output: 8 start The start() function returns the start date from a date range. It accepts a single date argument. Full reference: start // Assume a property \"Date\" exists, with // a row value of June 23, 2022 ‚Üí June 27, 2022 start(prop(\"Date\")) // Outpuut: June 23, 2022 end The end() function returns the end date from a date range. It accepts a single date argument. Full reference: end // Assume a property \"Date\" exists, with // a row value of June 23, 2022 ‚Üí June 27, 2022 end(prop(\"Date\")) // Outpuut: June 27, 2022 now The now() function returns the current date and time in your local timezone. now() accepts no arguments. Full reference: now now() // Output: June 23, 2022 12:30 PM (at time of writing) timestamp The timestamp() function converts a date argument into its corresponding Unix timestamp (also known as Unix Time or Epoch Time), which is a number. Full reference: timestamp timestamp(now()) // Output: 1656012120000 (will change with the value of now() fromTimestamp The fromTimestamp() function converts a Unix timestamp into a date. Full reference: fromTimestamp // Notion will express this date in your local time zone, so it // may look different if you try this formula out.hin fromTimestamp(1656012840000) // Output: June 23, 2022 7:34 PM (UTC) dateAdd The dateAdd() function accepts a date argument and adds to it, returning a new date. It requires three arguments in the following order: A date (must be an actual date data type) A number A unit Accepted units include: ‚Äúyears‚Äù ‚Äúquarters‚Äù ‚Äúmonths‚Äù ‚Äúweeks‚Äù ‚Äúdays‚Äù ‚Äúhours‚Äù ‚Äúminutes‚Äù ‚Äúseconds‚Äù ‚Äúmilliseconds‚Äù Full reference: dateAdd // Assume a property called \"Date\" with a current row value // of June 1, 2022 dateAdd(prop(\"Date\"),3,\"months\") // Output: September 1, 2022 dateAdd(prop(\"Date\"),5,\"days\") // Output: June 6, 2022 dateSubtract The dateSubtract() function accepts a date argument and subtracts from it, returning a new date. It requires three arguments in the following order: A date (must be an actual date data type) A number A unit Accepted units include: ‚Äúyears‚Äù ‚Äúquarters‚Äù ‚Äúmonths‚Äù ‚Äúweeks‚Äù ‚Äúdays‚Äù ‚Äúhours‚Äù ‚Äúminutes‚Äù ‚Äúseconds‚Äù ‚Äúmilliseconds‚Äù Full reference: dateSubtract // Assume a property called \"Date\" with a current row value // of June 1, 2022 dateSubtract(prop(\"Date\"),3,\"months\") // Output: March 1, 2022 dateSubtract(prop(\"Date\"),5,\"days\") // Output: May 27, 2022 dateBetween The dateBetween() function returns the amount of time between two dates, based on a specified unit of time. The function returns a number, and requires three arguments in the following order: Date 1 (must be a date data type) Date 2 (must be a date data type) A unit Accepted units include: ‚Äúyears‚Äù ‚Äúquarters‚Äù ‚Äúmonths‚Äù ‚Äúweeks‚Äù ‚Äúdays‚Äù ‚Äúhours‚Äù ‚Äúminutes‚Äù ‚Äúseconds‚Äù ‚Äúmilliseconds‚Äù Full reference: dateBetween // Assume now() == June 23, 2022 and Date == June 1, 2022 dateBetween(now(),prop(\"Date\"),\"days\") // Output: 22 // Assume now() == June 23, 2022 and Date == June 30, 2022 dateBetween(now(),prop(\"Date\"),\"days\") // Output: -6 // Assume now() == June 23, 2022 and Date == December 25, 2022 dateBetween(now(),prop(\"Date\"),\"months\") // Output: -6 formatDate The formatDate() function formats a date as a string using the Moment standard time format. Full reference: formatDate formatDate(now(), \"MMMM DD YYYY\") // Output: June 24 2022 formatDate(now(), \"dddd, MMMM DD, YYYY hh:mm A zz\") // Output: Friday, June 24, 2022 10:45 AM MDT formatDate(now(), \"[Month of] MMMM, YYYY\") // Output: Month of June, 2022 Good to know: formatDate() uses Moment.js for date formatting. minute The minute() function returns an integer (number) between 0 and 59 that corresponds to the minute of its date argument. Full reference: minute minute(now()) // Output: 25 (When current time was 11:25 AM) // Assume a propety called Date with a current date of June 24, 2022 11:29 AM minute(prop(\"Date\")) // Output: 29 hour The hour() function returns an integer (number) between 0 and 23 that corresponds to the hour of its date argument. Full reference: hour hour(now()) // Output: 11 (When current time was 11:25 AM) // Assume a propety called Date with a current date of June 24, 2022 11:29 AM hour(prop(\"Date\")) // Output: 11 day The day() function returns an integer (number) between 0 and 6 that corresponds to the day of the week of its date argument: 0 = Sunday 1 = Monday 2 = Tuesday 3 = Wednesdy 4 = Thursday 5 = Friday 6 = Saturday Full reference: day day(now()) // Output: 5 (when now() = June 24, 2022) // Assume a propety called Date with a current date of June 1, 2022 day(prop(\"Date\")) // Output: 3 date The date() function returns an integer (number) between 1 and 31 that corresponds to the day of the month of its date argument. Full reference: date date(now()) // Output: 24 (when now() = June 24, 2022) // Assume a propety called Date with a current date of June 1, 2022 11:29 AM date(prop(\"Date\")) // Output: 1 month The month() function returns an integer (number) between 0 and 11 that corresponds to the month of its date argument. Full reference: month month(now()) // Output: 5 (when now() = June 24, 2022) // Assume a propety called Date with a current date of Jan 1, 2022 month(prop(\"Date\")) // Output: 0 year The year() function returns an integer (number) that corresponds to the year of its date argument. Full reference: year year(now()) // Output: 2022 (When now() = June 24, 2022) // Assume a propety called Date with a current date of June 24, 2022 year(prop(\"Date\")) // Output: 2022 id The id() function returns the current row‚Äôs page ID, which is a unique string. id() accepts no arguments. Full reference: id // Page URL: <https://www.notion.so/thomasfrank/id-c5d67d15854744869cc4a062fb7b1377> id() // Output: c5d67d15854744869cc4a062fb7b1377 Formula Tips Here a few useful tips for working more effectively with formulas: Write Formulas in a Text Editor Full reference: Writing Complex Formulas in VS Code You can write formulas in a text editor like VS Code; this will allow you to use indentation, multiple lines, and comments. When you need to compress your formula for pasting into Notion, simply do a search-and-replace. Search for the following regular expression: (\\n[ ]{2,}|\\n|[/]{2}[^\\n]*) Copy and paste your formula. We‚Äôll compress one of the copies, leaving the other as an easy-to-read reference. Open the find and replace window with Ctrl/‚åò + F and paste the expression into the find field. Paste in the expression above. Click the Use Regular Expression button. Select the entirety of your formula (just one of the copies) Click the Find in Selection button. Ensure the Replace field is blank. Click the Replace All button. Return Empty/Null Values in Notion Formulas Full reference: Return Null/Empty Values in Formulas To return an empty string: \"\" To return an empty number: toNumber(\"\") To return an empty date: fromTimestamp(toNumber(\"\")) There is no possible null/empty state for Booleans/Checkboxes. However, you can convert Booleans to strings with format in order to create a setup where true/false/empty is possible: // Assume \"Checkbox\" is a Boolean/Checkbox property. // Invalid; will throw a Type Mismatch error: if( 1 > 2, prop(\"Checkbox\"), \"\") // Valid. Will output \"true\", \"false\", or an empty value. if( 1 > 2, format(prop(\"Checkbox\")), \"\") If you find this cheat sheet useful, you‚Äôll also love my Notion Tips newsletter! Join to get notified whenever I publish new tutorials, guides, and templates:","metadata":{"source":"https://thomasjfrank.com/notion-formula-cheat-sheet","title":"Notion Formulas: The Ultimate Cheat Sheet (2023)","date":"2022-09-12T19:56:09+00:00","contentLength":4157}},{"pageContent":"The most powerful and flexible tool in Notion is its database feature. Within your Notion workspace, you can create databases that can store almost any kind of data, including text, numbers, file attachments, and more. Databases can be used to create: Task managers (such as Ultimate Tasks) Calendars Note-taking systems CRMs Custom dashboards for sales and performance data ‚Ä¶and much more. Once you understand how to work with databases, you‚Äôll unlock a whole new level of capability inside of Notion. In this Notion Fundamentals lesson, I‚Äôll guide you through all the basics of creating and using databases. Note: This guide is massive, and is intended to be a truly complete tutorial for Notion databases. I encourage you to use the table of contents to jump around! In the video version of this lesson, we‚Äôll be using everything we learn to create a useful example database ‚Äì a simple task manager, which you could include in the personal dashboard that we‚Äôve been building throughout the other lessons in this series. One thing I‚Äôll note before we get started is that I‚Äôve created a completely free task management template called Ultimate Tasks, which has a lot more capabilities than the example we‚Äôll be building here ‚Äì such as sub-tasks, recurring tasks, progress bars for projects, and more. If you‚Äôre looking for a capable task manager for Notion, check it out! The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free How to Create a Notion Database The best way to learn is by doing ‚Äì by trying things out, experimenting, and getting your hands dirty. So let‚Äôs start this guide out by covering how to actually create a Notion database. Doing so is simple; just type /database on any Notion page, and you‚Äôll see a list of database options. You can start out by choosing Database ‚Äì Inline, which will create a brand-new database right on that page. Here‚Äôs a very simple example database that lists some of my favorite movies: By default, your new database will be displayed as a table. Notion offers other database layouts, but a table is a great starting point. There are a couple of alternative ways to create a database as well. First, you can create a blank page (see my lesson on creating pages), and then select one of the database options: You can also use the / command to create a database with the specific layout you want. The options include: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view If you create a database block using a layout command, Notion will give you the option to either create a Linked Database (which links to an existing source database), or to create a new database. There are later sections in this guide for both (click to jump to them): Database Layouts Linked Databases For now, it‚Äôs just useful to know the ways you can create new databases. Notion Databases at a Glance Databases store rows (sometimes known as records). And in Notion, those rows are actually Notion pages themselves. The Table layout in Notion displays a database‚Äôs rows as they‚Äôre actually stored in the database (since Notion uses a table-style database structure with rows and columns). In this example, each movie is a row in the database. However, I can open up any one of them and get a Notion page that works just like any other: These pages can hold any type of content you want ‚Äì text, images, and even other Notion databases. Databases also have properties. You can see these at the top of the Hot Fuzz page above, or as columns in the Table view. Properties hold structured information within a database, and typically they‚Äôre set on a per-row basis. Here in the movies database, I have two: Genre ‚Äì a Multi-Select property, which allows one or more tags to be applied to each record Seen Recently ‚Äì a simple Checkbox property Properties have several uses, but their greatest use is in filtering and sorting your data. Here‚Äôs another view of our Movies table, filtered to show only the movies that we haven‚Äôt seen recently: Note how this is a different view of the same database. Our original Table tab doesn‚Äôt contain the same filter. By looking at the same database through different views with unique filters, we can look at the same database in many different ways. This is immensely powerful. Consider a Notes database containing all the notes in your life. That might be thousands of notes! Without any filters, this data would be hard to sift through. But by applying properties, sorts, and filters, you could create all sorts of useful views: All notes created in the last month Notes tagged with ‚ÄúFitness‚Äù All notes, sorted by Date Last Updated Notes related to the Vacation project in your Project Database Notes with a Review Date that falls within the next week Without a database, these types of filters and sorts aren‚Äôt possible in Notion ‚Äì which means you may eventually end up with long lists of pages that can only be sorted by dragging-and-dropping. Hopefully, this introduction has shown you just how powerful databases can be. From here, the rest of this guide is a choose-your-own-adventure: You can scroll up to the video tutorial above, where we‚Äôll create a simple task manager using some slightly more advanced database techniques. Or, you can keep reading this written guide, which will detail all the important Notion database features ‚Äì filters, sorts, grouping, properties, relations, linked databases, and more. What Is a Database? Now that you‚Äôve had a proper introduction to how Notion databases work, I‚Äôd like to touch a bit on what databases actually are before we get into the details of their individual features within Notion. In general, a database is defined as an: ‚Äú‚Ä¶organized collection of data stored and accessed electronically.‚Äù Nearly every program and web app you use relies heavily on databases. If you‚Äôve ever used a digital calendar app like Google Calendar, then you‚Äôve benefited from a database. Behind the scenes, every event on your Google Calendar is a row in a database. These rows have properties, just like the ones you saw in this guide‚Äôs introduction. Some of these include: Event date Location Calendar (Work, Personal, etc.) Google Calendar uses the values stored for these properties in each row to intelligently display your calendar, showing you each event on its correct day slot, displaying the event‚Äôs location, and color-coding each event based on its Calendar. Notion works in much the same way, but it gives you a lot more control over your databases. You can create your own properties, customize them, and set up database views that display your data based on filters, sorts, and more. Here‚Äôs an example: What if I just wanted to see events on my Work calendar in the month of August? In Google Calendar, I‚Äôd toggle all my other calendars to their ‚Äúoff‚Äù state, and navigate to the correct month: In Notion, I could achieve the same result by first ensuring that I have properties in my Events database for Date and Calendar. Then, I could simply create a view with two filters: Where Calendar contains Work Where Date is within August 1 ‚û° August 31 Of course, Notion also includes a Calendar layout, so the date filter might not be necessary. I just wanted to show you how you‚Äôd directly interact with your database properties to create unique, filtered views. Databases vs. Spreadsheets You might have looked at all our example table views in the screenshots and thought, ‚ÄúHey, those look like spreadsheets!‚Äù Indeed, they do look like spreadsheets ‚Äì but they‚Äôre not. There‚Äôs a fundamental difference between spreadsheets and databases. On a spreadsheet, data is contained within cells that have specific X:Y coordinates on a grid, such as B2 or D5. This means that formulas can reference specific cells, like B2+D5 ‚Äì this simple formula will add the values of B2 and D5. Conversely, databases don‚Äôt really have ‚Äúcells‚Äù with X:Y coordinates. Rather, each record has the same number of properties, each of which can be set to a unique value per record. Technically, since most databases are relational and store data in a table with rows and columns, you could feasibly target coordinates on the table. But since databases are built to be flexible, the vast majority of database tools don‚Äôt provide spreadsheet-like cell coordinates for row:property pairs. We can display a database in a grid-like table, but it‚Äôs not actually a grid of cells that we can target. This means we can easily visualize the information in our database in other ways besides a classic table ‚Äì such as a Kanban-style board, where the columns are based on the Assignee property: Spreadsheets and databases do have quite a bit of overlap, though. In a spreadsheet, we can simulate properties by creating a two-dimensional table. And apps like Excel even allow us to sort of treat a spreadsheet like a database through pivot tables and other functions. Likewise, an app such as Notion can let us view a database‚Äôs table structure, which looks like a spreadsheet. The most important thing to know as a Notion user, however, is that we can‚Äôt target individual row:property combinations as if they were cells on a grid. Here on my task table, I couldn‚Äôt write a formula that specifically targets the ‚Äúcell‚Äù with ‚ÄúApril 6‚Äù in it. In Excel, you might think of that location as B3, but there‚Äôs no B3 in Notion. Instead, there‚Äôs a row ‚Äì the ‚ÄúTest Web Parachute‚Äù row ‚Äì and its Due Date property is set to April 6. It‚Äôs also worth noting that ‚ÄúTest Web Parachute‚Äù is itself a specific value in the Name property. In Notion, new databases get a default property called Name, which can‚Äôt be hidden or deleted. But it is still a property ‚Äì just a special property. Its type is ‚ÄúTitle‚Äù, and you can actually open it up to see a brand-new Notion sub-page within your database. If you want to get even nerdier about spreadsheets and databases, check out this article comparing them. With this high degree of control and flexibility, you can use databases to create all sorts of different tools and applications inside of Notion. After all, many software tools are just collections of filtered database views! Consider: Your phone‚Äôs contacts app Task managers like Todoist Websites like IMDB Each of these simply gives you tools to work with one or more databases. As a result, you can create replacements for all of these tools inside of Notion. You can also create hyper-personalized tools that fit the exact information and processes you use for your work. That‚Äôs Notion‚Äôs superpower. It allows you to build tools that don‚Äôt yet exist, tailored to your exact needs. Notion Database Examples Book Tracker Contact Manager Simple Task Manager As we dig into all the particulars of Notion‚Äôs database tools, you might want some example databases to play around with. Here are a few, which will also serve to show you some of the tools you can build within Notion. Simple Task Manager Contact Manager Book Tracker Each of these databases is available as a free template, which means you can duplicate them into your Notion workspace and make changes to the duplicated copy. Learning happens fastest when you take action, so experiment and make some changes! Add some stuff! Let your cat walk on your keyboard for a minute and then try to fix everything that broke! There are 3 ways to make progress in anything:1. Buy new gear.2. Learn academically through books, courses, etc.3. Spend time in deliberate practice.In order of importance:Practice > Learning >>>>> Gear‚Äî Thomas Frank (@TomFrankly) May 29, 2022 I‚Äôll also note that these are very simple example templates. They purposely lack a lot of features so that they‚Äôre easy to understand and edit. I‚Äôve also designed several more robust templates with advanced features. These templates are completely ready to rock, and will instantly upgrade your Notion workspace with useful tools. Check them out on my Notion Templates page. We‚Äôre now ready to start digging into all of the features that Notion databases offer. From here, you may want to use the Table of Contents to the left (or at the top of this article if you‚Äôre on mobile) in order to find the topic you most want to learn about. Database Views A database view is a specific combination of layout, filters, sorts, etc. Note that a database block can contain multiple views. When it does, you‚Äôll see them all listed across the top as tabs: Each of these views pulls from the same database, but each shows a unique set of data based on a combo of sorting, filtering, and layout. You can also add a new view to a database block using the Add view button: For each view, you can access a View Options menu, where you‚Äôll be able to change nearly any setting related to that database view: Here, you‚Äôll have access to nearly every setting inside your database, including: Database name Layout ‚Äì Table, Board, Calendar, etc. Property settings ‚Äì show/hide properties on the current view Filter options Sort options Group options Load Limit ‚Äì sets the max number of rows that will be loaded automatically (you can load additional rows using the Load More button at the bottom of any view) Lock Database/Lock Views ‚Äì On a source database, this will lock the entire database. On a Linked Database, you‚Äôll see Lock Views, which merely locks the Linked Database‚Äôs views from being changed. (Learn more about locking databases) Copy Link to View ‚Äì copies the link to the current database view to your clipboard Duplicate View ‚Äì duplicates the specific view you‚Äôre currently on Delete View ‚Äì deletes the specific view you‚Äôre currently on Layout Types Notion databases can be viewed in several ways. You‚Äôve already seen the Table layout in our examples above, but that‚Äôs just one of six available layouts: Table ‚Äì a traditional, spreadsheet-like view Board ‚Äì a Trello-style ‚ÄúKanban‚Äù view Timeline ‚Äì a Gantt chart view Calendar ‚Äì a no-frills Calendar view List ‚Äì a responsive, mobile-friendly Table alternative Gallery ‚Äì an aesthetic view that‚Äôs great for showcasing images Each one of these layout types gives you a different way of displaying the same information from your database. They each have their own advantages, disadvantages, and features, so try them all out! Add New Pages to a Database You have a few different options for adding new pages to your database. First, you can hit the +New button within your database view. In a Table view, you‚Äôll find it at the bottom of the table: It‚Äôs worth noting that this is the only way to add a row that will conform to the view‚Äôs filters automatically. Example: If the view above had a filter that said ‚ÄúGenre is Action‚Äù, then your new row would automatically be tagged with Action. This is called a forcing function. Click here to jump to the section of the guide on forcing functions. You can also hit the blue New button in the top-right corner of any database view. This will open up a modal window with a blank record in the database. Additionally, you can create new rows in a specific database from anywhere in your Notion workspace by using the + link syntax, then choosing the ‚ÄúNew page in‚Ä¶‚Äù command. For example, I could add a new row to my Movies database from anywhere by typing +Ghost in the Shell, choosing New page in‚Ä¶, and then selecting the Movies database as the destination. Learn more about this in my guide on linking Notion pages together. Finally, you can add new rows to a Notion database through external tools. For example, the official Notion web clipper and the Save to Notion extension can both clip web pages into your Notion workspace. If you want to get more advanced, you can even use the Notion API to add new database rows using thousands of other tools. Database Properties Properties are the columns in a database‚Äôs table structure, and they‚Äôre useful for holding structured information about each row. They let you add dates, checkboxes, tags, numbers, and a lot more to your databases. In a Table view, you‚Äôll see your database‚Äôs properties as columns: In other layouts, you‚Äôll see property values listed on the cards for each row: You can show/hide individual properties on any given view by going to View Options ‚Üí Properties: By opening up a row as a page, you‚Äôll be able to see all of the properties in that row‚Äôs database. You can also easily add new properties here. Notion comes with many different types of properties. Some are writable, meaning you can edit the information they hold on each row. Others are read-only, meaning they hold information that can‚Äôt be edited. Here‚Äôs a table showing all of Notion‚Äôs property types: Property Description R/W Text Holds text, which can be formatted. Writable Number Holds numbers. Can be formatted as a progress bar. Writable Select Holds singular ‚Äútags‚Äù. Writable Multi-Select Can hold multiple ‚Äútags‚Äù. Writable Status Indicates project/task status. Always has a default value. Can show as text or a checkbox. Writable Date Holds dates, which can be displayed absolutely (e.g. ‚Äú03/25/22‚Äù) or relatively (e.g. ‚ÄúTomorrow‚Äù). Writable Person Holds members or guests of the workspace. Writable Files & Media Holds file attachments, including images, audio files, video, etc. Writable Checkbox Holds a simple checkbox. Writable URL Holds a URL, which is clickable. Writable Email Holds an email address. Writable Phone Holds a phone number, which can be called on supported devices. Writable Formula Holds formulas that can process and output data in many ways. Read-Only Relation Relates the row to other rows in the same database or another database. Writable Rollup Pulls in property information from Related rows. Read-Only Created time Holds the date and time of the row‚Äôs creation. Read-Only Created by Holds the workspace user who created the row. Read-Only Last edited time Holds the date and time of the row‚Äôs last edit. Read-Only Last edited by Holds the workspace user who last edited the row. Read-Only One last useful thing to know about properties is that they can be deleted and restored. If you accidentally delete a property, just head to View Options ‚Üí Properties ‚Üí Deleted Properties to find it and restore it (or permanently delete it if you want): Sorting You can sort a database view by any property, in either ascending or descending order. To create a sort: Hit the Sort button at the top of your database block. Select the property by which you‚Äôd like to sort your view. Choose ascending or descending order. Add additional sort criteria if you want. By adding additional properties, you can create even more granular sorts in your database views. In these cases, the database will be sorted by each property in top-to-bottom order. Drag properties around to change the sort order. Here, you can see that I have this shot list database sorted first by Type, then by B-Roll Description. P.S. ‚Äì This shot list database is part of Creator‚Äôs Companion, my all-in-one Notion template for content creators. Check it out if you make videos, blog posts, or social media content. If you create a sort within a database that is shared with others (Team Members or Guests), your sort will initially only be visible to you on your current device. You‚Äôll notice a Save for Everyone button after creating the sort; click it if you want to apply the sort to the database for everyone. You can also click Reset to remove any changes you‚Äôve made, or simply leave things as-is if you want to keep the sort for your eyes only. If you‚Äôre working on a database that‚Äôs private, you won‚Äôt see these options; they only come up on shared databases. Filters Databases often contain huge amounts of data, but you rarely need to see all of it at once. Typically, you just need to see the rows that are relevant to a specific context, like: Tasks that are due today Subscribers who are less than 30 days away from their renewal date Movies in the Action genre This is where filters come in. Filters allow you to limit the rows a view displays, and they‚Äôre among the most useful tools you‚Äôll find in Notion. Just like a sort, you can create a filter by hitting the Filter button at the top of your database block: There are two types of filters in Notion: Simple Filter ‚Äì a singular filter that targets one property Advanced Filter ‚Äì a set of filters or filter groups Simple Filters Simple filters are quick to create and target a single property. To create one, hit the Filter button and then select the property you‚Äôd like to filter by. Filters follow this convention: Property Name ‚Üí [Criteria] ‚Üí Value Here, you can see that I‚Äôm filtering my view by the Genre property, which has the Multi-Select property type: Your criteria options will change depending on the property‚Äôs type. Here, I have four options: Contains Does Not Contain Is Empty Is Not Empty Finally, I can choose one or more values. My completed filter reads: Genre Contains Action, which means my view will only show rows that have Action in their Genre property. Since Genre is a Multi-Select property, rows can also contain other genres. You can add multiple simple filters to a database view, and you‚Äôll see them displayed in a row across the top of your database view when the Filter bar is open. Advanced Filters An Advanced filter is a set of one or more filters that show up in a single dialogue box. Using an advanced filter, you can do something that‚Äôs incredibly useful; you can mix AND/OR operators when working with multiple filters. When you create multiple simple filters, you‚Äôre always using the AND operator between them. For example: ‚ÄúGenre contains Action‚Äù AND ‚ÄúSeen Recently is Checked‚Äù. By creating an advanced filter, you could instead set up this filter combo: ‚ÄúGenre contains Action‚Äù OR ‚ÄúSeen Recently is Checked‚Äù. Note how this drastically changes the rows that show up in this view! Now, a row only has to fit one of the filter criteria. Advanced filters also let you create filter groups. Within an advanced filter, click the Add Filter Rule dropdown and then select Add Filter Group to create one: Filter groups let you mix your AND/OR operators. Normally, once you‚Äôve chosen either AND or OR, you‚Äôre locked into that choice when you add more rules to the filter. However, a filter group gives you a nested box where you can select a new operator. How is this useful? Here‚Äôs an example problem: Say I‚Äôm a movie buff. I want to watch a movie every night, and I have these preferences: I‚Äôm an action movie nut, so I might want to watch an action movie even if I have seen it recently. For other genres, I only want to watch a movie if I haven‚Äôt seen it recently. Using a filter group, I can create a view that fits both of these preferences. In my Movies database, I‚Äôve created the following set of filters: If a row contains the Action genre, it‚Äôll always show up. If it doesn‚Äôt contain the Action genre, it‚Äôll only show up if Seen Recently isn‚Äôt checked. Here‚Äôs another example from my Ultimate Brain template: Ultimate Brain has a robust note-organization structure (modeled on Tiago Forte‚Äôs P.A.R.A. method) with: Higher-level Areas Lower-level Resources Areas can contain Resources, and Notes can exist in Areas or Resources. This means that within an Area, we‚Äôd want to show Notes that exist directly in that Area, or that exist within any Resources underneath that Area. We also want to make sure those Notes aren‚Äôt archived. Using a filter group, I‚Äôve created a combo of AND and OR operators to meet these criteria. This example is more complex than the previous one, but I hope that it illustrates how filters can allow you to create truly useful tools directly within Notion! P.S. ‚Äì If you‚Äôd like to use Notion as a true Second Brain, check out my Ultimate Brain template. It seamlessly combines tasks, notes, projects, goals, and whole-life organization, and it‚Äôs what I use as my own productivity system. Saving Filters As with sorts, filters created in shared databases will initially only affect your account and device. When you create a new filter or change/delete current filters, you‚Äôll see a Save for Everyone button pop up: You can click that to apply the filter for everyone who has access to the database, hit Reset to erase your changes, or just leave things as they are if you want the filter to only affect you. Forcing Functions When you set up a filter in a database view, new rows created in that view must conform to that filter. As a result, creating a new row in a view with filters will automatically set default property values. Here‚Äôs an example: In this view of the Movies database, I‚Äôve created the following filter: Seen Recently is Checked. Note how the new row I‚Äôve added automatically has its Seen Recently checkbox property checked. When filters are used in this way, I call them forcing functions. You can use these in all sorts of ways ‚Äì here are just a few ideas: Add tasks to a task view with a due date set to Today Add notes to a filtered notebook view with a specific tag, such as Lecture or Book Add tasks to a shared task database with a specific Assignee (person property) I‚Äôve made an entire video explaining how these work (and how to use them to your advantage) in a lot more detail: Grouping Notion lets you group rows in a database view based on common values in nearly any property type. Here, I‚Äôve grouped my Movies database view by the Genre property. Now my movie rows are grouped by genre: You can add Grouping to any view layout (except for Calendar) by going to View Options ‚Üí Grouping. From there, you‚Äôll be able to select the property you‚Äôd like to use for grouping: You‚Äôll also find a few other options, such as Hide Empty Groups. Sub-Grouping Notion‚Äôs Board layout has a unique feature: In addition to Grouping, it can have Sub-Grouping as well. Normally, a Board view will display its groups as columns. This is the classic ‚ÄúKanban‚Äù style of grouping that has its origins in Japanese manufacturing, and which was popularized in the U.S. by apps like Trello. By adding sub-grouping, you can group a board view into distinct rows. In this case, the rows aren‚Äôt actual database rows (as in a Table view); they‚Äôre sub-groups based on another property. In the screenshot above, I‚Äôve grouped the Board view by Genre, and then sub-grouped it by a new Select property called Rating. Movies are grouped by their ratings ‚Äì PG, PG-13, R, etc. You can add sub-grouping to a Board view in nearly the same way you‚Äôd add grouping ‚Äì simply navigate to View Options ‚Üí Sub-Group. Relations The Relation property type allows you to relate database rows to each other. These relations can be created: Between rows in the same database Between rows in separate databases This concept can take a bit of time to fully grok, so let me start out with an example. Example 1: Parent and Child Tasks Task managers often have a sub-tasks feature, which lets you nest sub-tasks underneath a top-level ‚Äúparent‚Äù task. Here‚Äôs a task with a couple of sub-tasks in Todoist: When you open the Parent Task 1‚Äôs window as in the image above, how does Todoist know to show you two sub-tasks ‚Äì and not show you any other tasks? Behind the scenes, there‚Äôs a Relation set up in Todoist‚Äôs database. This Relation consists of two properties, which you could think of as columns in a table: Parent Task Sub-Tasks The Parent Task 1 database row has its Sub-Tasks Relation property filled with links to two other database rows: Child Task 1 Child Task 2 Likewise, each Child Task has its Parent Task Relation property filled with a link to the Parent Task 1 row. In this way, Parent Task 1 is related to the two Child Tasks. With this Relation set up, Todoist can simply use a filter (also behind the scenes) to display the correct Child Tasks. Essentially, that filter would read: Where Parent Task contains ‚ÄúParent Task 1‚Äù This filter ensures that only the two Child Tasks show up. If that makes sense so far, let‚Äôs create it in Notion! How to Create a Single-Database Relation A Relation is a type of property, so you can add one to your database by: Adding a new property Selecting the Relation type Selecting the Database you‚Äôd like your Relation property to point towards Choosing whether the Relation should have separate properties Since I‚Äôm creating a Parent Task ‚¨å Sub-Tasks relation, I want to make sure I choose the same database that I‚Äôm currently working with ‚Äì in this case, My Tasks. Next, I‚Äôll choose whether or not I want to create Separate Properties. If I don‚Äôt, I‚Äôll just get a single Relation property called Sub-Tasks. If I do turn it on, I‚Äôll get a second property. Since I do want a second property called Parent Task, I‚Äôll turn on the Separate Properties option and give my second property the correct name: Now that I have my Relation properties, I can model Parent Tasks and Sub-Tasks just like we did earlier with Todoist. Here, I‚Äôve clicked into the Sub-Tasks property within the ‚ÄúTake Grocery Boxes‚Ä¶‚Äù row, and set two other rows as sub-tasks: Build grocery boxes Get rain covers Note how ‚ÄúTake Grocery Boxes‚Ä¶‚Äù automatically shows up in the Parent Task property for each of these sub-tasks. Now that we have these Relations set up, we can do some useful stuff! Here‚Äôs a basic example. I‚Äôve set up a simple filter that says: Where Parent Task contains ‚ÄúTake Grocery Boxes‚Ä¶‚Äù With this filter in place, I can only see the two sub-tasks I created earlier. In the Linked Databases section of this guide, I‚Äôll show you how to set up this same filtered view inside the Parent Task‚Äôs page. This is far more useful, and it models the Todoist example above perfectly. For now, let‚Äôs take Relations one step further by relating two separate databases together. Example 2: Tasks and Projects Task managers also tend to have Projects or Lists that are useful for grouping multiple tasks together. You can see this in Todoist: If we think about the databases that run everything behind the scenes, we realize that there are actually two main databases: Tasks Lists These databases are related to one another. This means that a single row in the Lists database can be related to many rows in the Tasks database. Then, using filters, Todoist can show you a tidy view of the tasks in a specific list, such as House. Guess what? You can do the exact same thing in Notion by creating a multi-database Relation! How to Create a Multi-Database Relation To create a multi-database Relation, we‚Äôll first need two databases to work with. Fortunately, the Simple Task Manager example template already has two: My Tasks My Projects I can create my Relation in either database, but I‚Äôm going to create it in My Tasks. Adding a new Property, I‚Äôll: Name it Project Select the Relation property type Select the My Projects database for the database connection Toggle Show on My Projects to the On position Name my Related Property with the My Projects database as ‚ÄúTasks‚Äù Note how the Relation builder also gives you a preview of what your Relation looks like. Here, you can see that two properties are being created: ‚ÄúProject‚Äù within the My Tasks database ‚Äì which points to the My Projects database ‚ÄúTasks‚Äù within the My Projects database ‚Äì which points to the My Tasks database These two properties are reciprocal, meaning that setting a related row in one will affect the other. In My Projects, the Suit Redesign project contains two related rows from My Tasks: Going over to My Tasks, we can see that both of these rows ‚Äì Design new web shooters and Test web parachute ‚Äì contain Suit Redesign in their Project property. With this Relation set up, I can do some very useful things. For example, I can group this view by my Project property. I can also set up a database view within a Project‚Äôs page that shows only its related tasks. To do that, I‚Äôll need to use a Linked Database. Linked Databases Linked Databases allow you to create a database block that pulls data from an existing source database, which can live elsewhere in your Notion workspace. For example, the main All Tasks database inside my Ultimate Brain template lives inside the Archive: On Ultimate Brain‚Äôs Quick Capture page, there‚Äôs a Linked Database block that uses All Tasks as its source: This means that any rows I add to this linked database view will end up in the All Tasks database. Essentially, you can think of Linked Databases as collections of Views for a database that can live elsewhere in your Notion workspace. Linked Databases are immensely useful. They allow you to create pages and dashboards in Notion that are driven by source databases, but that serve specific contexts. The Quick Capture page shown above is just one example of a context-specific page. Here‚Äôs another one ‚Äì this page only shows tasks that are due on or before tomorrow: Note that this Linked Database view has the source database hidden; this is an option you can turn off or on. How to Create a Linked Database You can create a Linked Database in Notion either by typing /Linked view of a database or by typing any of the following options: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view I‚Äôll go with /Linked view... inside the Suit Redesign project in the My Projects database. That way, I‚Äôll be able to get a view of all the tasks related to this project. The first thing I have to do is select a data source. This is the source database that I want to pull from. In this case, I want to select My Tasks: Next, I‚Äôll be given the option to either copy an existing view from the source database or to create a new empty view. I‚Äôll do the latter so I can completely customize it: From here, I can customize my view just like I would with a normal view inside the source database. All of the options are exactly the same. The only difference is that the Linked Database view comes with the option to show or hide the source database title. Here, I‚Äôve hidden it in order to make my database view look cleaner: The last thing I‚Äôll do here is add a filter to my linked view: Project contains Suit Redesign This will ensure that only tasks related to my Suit Redesign project show up. It also creates a forcing function, ensuring that new rows I add to this view will automatically be related to the Suit Redesign project! With this simple filter in place, my Project page works just like a List in Todoist (or any other task management app). Database Templates Pages inside a Notion database act just like normal Notion pages ‚Äì they give you a blank canvas on which you can add any combination of blocks. But you won‚Äôt always want to start from scratch; sometimes, you‚Äôll want to have a common starting point for certain pages in a database. That‚Äôs where database templates come in. By creating templates in your database, you can automatically generate any page content you want with just one click. Templates can be as simple or as complex as you want them to be. Here‚Äôs a very simple template within my Movies database: ‚Ä¶and here‚Äôs the comprehensive Content Project Template that I use for all of my YouTube videos. In one click, it generates a task list, shot list, script page, research area, multiple checklists, and more: Note how it also sets default values on some of my database‚Äôs properties ‚Äì including the Status, Channel, and #No properties. If you‚Äôre a content creator, you can get access to this template ‚Äì along with a whole suite of dashboards and tools to aid your creation process ‚Äì in my Creator‚Äôs Companion template. It‚Äôs the exact system I use to run my YouTube channels and blogs (including this one). When you have a template created within a database, you‚Äôll see an option to use it whenever you create a new page in that database and open and open it: You can also create a page from an existing template by clicking the arrow next to the blue New button in your database‚Äôs top-right corner, then selecting a template: How to Create a Database Template You can create a new template by clicking the arrow next to the blue New button in the top-right corner of your database, then clicking New Template. From there, you can add any content you want to the template. You can also set default values in properties, which will be applied to any new page that you generate from the template. Default Templates After you‚Äôve create a database template, you can choose to have that template automatically applied to any new pages you create. You can do this in two different ways: Set the template to be applied only on new pages in the current database view Set the template to be applied on pages created in all views of the database To set a template as a default, click the blue arrow next to the New button and find your template. Then click the ‚Ä¢‚Ä¢‚Ä¢ menu next to the template and choose Set as Default. Once done, you‚Äôll see the options I mentioned above: Choose ‚ÄúFor all views‚Äù if you want the template to be applied in all views of the database (i.e. it will always be applied). Choose ‚ÄúOnly on‚Ä¶‚Äù if you want the template to only be applied on the current view of the database. Self-Referential Filters One of the most useful things you can do with a database template is to combine it with a Linked Database and set up what‚Äôs called a self-referential filter. If you wanted to create a database template inside a Projects database, which shows all the tasks related to the current project, you‚Äôd use a self-referential filter for that. Note: Self-referential filters are tools for Notion power users. You should be familiar with Relations and Linked Databases before worrying about them. A self-referential filter is a filter inside a database template that updates itself when you create a new page from that database template. Specifically, a self-referential filter: Is set on a Linked Database that is placed within a database template. Filters a Relation property, which targets the database that contains the database template. Targets the database template itself. Essentially, a self-referential filter helps you filter a linked database view so that it only shows rows that are related to the page that contains that linked database. When you set it up in a database template, you set it to target the template itself ‚Äì but when you create a page from that template, the filter updates itself! Here‚Äôs a look at one in action. Here, I‚Äôm editing the Project Template in the My Projects database. I‚Äôve created a linked database, which points to the My Tasks source database. In the filters, I‚Äôve set up a filter that states: Project contains Project Template This means that only rows with Project Template set in their Project Relation would show up here. Of course, filtering for Project Template wouldn‚Äôt be very helpful. It‚Äôs a template, not an actual project. But watch what happens when I create a new project ‚Äì Suit Redesign ‚Äì and generate its page content from the Project Template: As you can see, my filter has automatically updated itself! Now it reads: Project contains Suit Redesign Crucially, I didn‚Äôt have to edit the filter myself. That‚Äôs the beauty of a self-referential filter; it auto-updates so that it targets your current database page instead of the database template. Rollups The Rollup property type allows you to pull property information from any rows that are connected to your current row through a Relation. You can also perform calculations on that information. To create a Rollup, add a new property just as you‚Äôd do for all other property types. Then set the Relation, Property, and Calculate options (explained below). Here, I have a Rollup called Undone Count in the My Projects database. It‚Äôs configured to show the state of the Done property for each of the rows that are related to my Suit Redesign row: See how the Rollup essentially allows me to pull information about the properties in these related rows? Not only that, but it collects this information in a single area; in other words, the information is ‚Äúrolled up‚Äù! Rollups have three configuration options: Relation ‚Äì the Relation property in your current database that you‚Äôd like to ‚Äúreach through‚Äù Property ‚Äì the Property in the database where the other side of the Relation exists (e.g. my Tasks Relation points to the My Tasks database, so it‚Äôs targeting the Done property of the rows there) Calculate ‚Äì the way in which you‚Äôd like to display the information By default, Rollups will use the Show Original setting within the Calculate dropdown. However, you‚Äôll find lots of other choices depending on the property type that you‚Äôre rolling up. If I set Calculate to Unchecked, I get a count totaling all the unchecked rows related to this project. In this case, both of the related tasks have been done, so the count is 0. Formulas Learn even more about formulas in my comprehensive Notion formula reference guide. Or, if you‚Äôre short on time, check out my one-page Notion formula cheat sheet. The Formula property type allows you to write formulas that can: Pull in data from other properties Format and change data Do complex calculations Run if-then scenarios with multiple potential outcomes Notion‚Äôs formula property is by far its most complex, and there‚Äôs essentially no limit to what you can do with it. Fun fact: My Ultimate Brain template contains a 10,000-character formula that does complex recurring-date calculations directly in Notion! You can create a formula property in Notion in the same way that you‚Äôd create any other property. From there, you can click the property‚Äôs content area to open up an editor where you can write formula code: Underneath the editor, you‚Äôll find a list of properties, functions, and more that you can use to create your formula. These include: Properties ‚Äì includes all the properties in your current database Constants ‚Äì such as e, pi, true, false Operators ‚Äì if, add, subtract, greater than, less than, etc. Functions ‚Äì join, slice, format, toNumber, etc. Since this is an overall guide to Notion databases, I won‚Äôt delve too deeply into how to write formulas here ‚Äì check out the full formula reference guide for that. For this post, I‚Äôll share two example formulas and explanations that will help you get started with writing your own formulas. Both of these can be found in the Simple Task Manager example template! Formula Example 1: Combine Numbers and Text The first formula we‚Äôll cover can be found in the My Projects database within the Simple Task Manager template. The property is called Meta, and it simply takes the number from the Undone Count property and formats it to look nicer. Here‚Äôs the ‚Äúcompact‚Äù version of the formula that you can easily paste into Notion: format(prop(\"Undone Count\")) + \" Tasks Left\" Note: If you paste this formula into a brand-new Notion database, you‚Äôll need the Undone Count property to exist first. Otherwise, you‚Äôll get a Property Not Found error. I prefer to write my formulas in a code editor (such as VS Code) and then make them compact using this Excel Formula Beautifier (which can either ‚Äúbeautify‚Äù code or compress it). As the name implies, it‚Äôs meant for Excel formulas ‚Äì but it works perfectly on Notion formulas as well. In fact, Notion‚Äôs formula syntax is extremely similar to Excel‚Äôs formula syntax. Here‚Äôs a version of the formula that‚Äôs easier to read: format( prop(\"Undone Count\") ) + \" Tasks Left\" The first part of this formula is: format(prop(\"Undone Count\")). It uses the prop() function to pull in the value of the Undone Count property, which is a Rollup (see the Rollup section above to learn more about those). I‚Äôm wrapping prop(\"Undone Count\") within the format() function in order to turn it into a String (which is basically just text). Notion formulas can output four different data types: String (plain text) Number Date Boolean (true/false, shown as a checkbox) However, a single formula can only output one data type. In other words, you can‚Äôt mix data types. Instead, you need to convert data types so that all of your output has the same type. The Undone Count Rollup property outputs a number, but ultimately my formula needs to output a string ‚Äì e.g. ‚Äú3 Tasks Left‚Äù. To achieve that, I use format() to transform that number into a string. It still displays as a number, but since it‚Äôs a plain-text string now, it can no longer be used in calculations (addition, multiplication, etc). Finally, I use the + operator to add my formatted number to this string: Tasks Left. Put them together, and you achieve a data-driven final output, such as: 3 Tasks Left! Formula Example 2: If-Then Statement Next, let‚Äôs look at how you can create variable output in a formula by using an If-Then statement. In the My Tasks database within the Simple Task Manager, I‚Äôve created a formula property called State. This property outputs a different symbol based on the status of the task: ‚è∞ = task is overdue üòÅ = task is done üü¢ = task is due today or later Here‚Äôs the compressed formula code, which you can easily paste into Notion: if(prop(\"Done\") == true, \"üòÅ\", if(dateBetween(now(), prop(\"Due\"), \"days\") > 0, \"‚è∞\", \"üü¢\")) Note: If you paste this formula into a brand-new Notion database, you‚Äôll need the Done and Due properties to exist first. Otherwise, you‚Äôll get a Property Not Found error. And here‚Äôs an expanded version of the formula that‚Äôs easier to read: if( prop(\"Done\") == true, \"üòÅ\", if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"‚è∞\", \"üü¢\" ) ) This formula has an if-then statement with another if-then statement nested inside it. By nesting if-then statements, we can create a formula that has more than two possible outcomes. To help you fully understand this formula, let‚Äôs first break down how if-then statements work. The basic syntax for an if-then statement in Notion is: if([test condition],[outcome if true],[outcome if false]) Essentially, we run a test, then define what do to if that test passes, and what do to if it fails. Here‚Äôs a bare-bones example: if(prop(\"Done\") == true,\"üòÅ\",\"üò°\") The == operator is testing whether the two pieces of information on either side of it are the same. Done is a checkbox property (with the data type boolean), so it outputs true or false. If the output of Done matches true, then the first option will be output: üòÅ. If not, Notion will output the second: üò°. Here‚Äôs where things get interesting ‚Äì either of the output paths in an if-then statement can contain additional functions. This can include more if-then statements! So let‚Äôs walk through the nested if-then statement from our example above: if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"‚è∞\", \"üü¢\" ) This statement will only be evaluated if the outermost if-then statement ‚Äì if(prop(\"Done\") == true ‚Äì returned false. This inner if-then statement tests to see whether the task is overdue or not. To do that, it uses the dateBetween() function, which finds the amount of time between two dates. I‚Äôm passing three arguments to this function: The now() function, which is built into Notion and returns the current date and time prop(\"Due\"), which returns the task‚Äôs due date \"days\", which simply specifies the unit of time dateBetween() should count by Finally, I check if the output of dateBetween() is greater than (>) zero. If it is, then the task is overdue and my formula outputs the ‚è∞ symbol. If not, the task is not overdue and the formula outputs the üü¢ symbol. As you can see, Notion formulas are extremely flexible and powerful. It‚Äôs also worth noting that practicing with Notion formulas is a good first step into actual programming if that‚Äôs something that interests you! Locking Databases Databases can take a long time to configure, and chaos can ensue if someone accidentally deletes a property, changes the settings of a view, or messes with a formula. Fortunately, Notion allows you to lock your databases in order to prevent these kinds of changes. To lock a database, first navigate to its original location. Open up the View Options menu and click Lock Database: When a database is locked, you won‚Äôt be able to make changes to its structure. You‚Äôll still be able to create new rows and set property values, but you won‚Äôt be able to: Add new properties Delete properties Change property settings (e.g. change a formula) Add/edit/delete options from a Select or Multi-Select property Fortunately, if you need to make a change, you can easily unlock the database by clicking the Locked button at the top. Note that you‚Äôll need to navigate to the original database to find this Locked button; you won‚Äôt see it on Linked Databases. Wrapping Up Whew ‚Äì we‚Äôre done. In this guide, we‚Äôve covered every main feature you‚Äôll find within Notion databases. You‚Äôre now ready to go out and start creating your own databases. Using the features we‚Äôve covered here, you‚Äôll be able to create useful tools that fit your individual workflows and tasks like a glove ‚Äì rather than relying on old-school productivity tools that don‚Äôt quite match the way you want to work. To learn even more about Notion, head to the Notion Fundamentals home page to check out all the lessons in this free series. You can also check out my Notion Templates, which can give you a head start and equip your workspace with an advanced task manager, note-taking system, habit tracker, and more. If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-databases-the-ultimate-beginners-guide","title":"Notion Databases: The Ultimate Beginner‚Äôs Guide","date":"2022-06-03T16:37:44+00:00","contentLength":8787}}]